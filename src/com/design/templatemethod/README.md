# 템플릿 메소드 패턴 (알고리즘 캡슐화)

## simplebarista

coffee class및 tea class에서 공통적인 부분이 있음. (boilWater, pourInCup)

## barista

위 simplebarista 의 coffee, tea class의 공통적인 부분을 추상화함. - 1차버전
이후 prepareResipe()의 공통부분을 추상화함 - 2차버전 p320
  
여기까지가 기본적인 템플릿 메소드 패턴

CaffeineBeverage.class의 prepareRecipe method가 템플릿 메소드다.   
즉, prepareRecipe는 메소드인데 어떤 알고리즘에 대한 틀(템플릿)역할을 한다.  
템플릿내에서 알고리즘의 각 단계는 메소드로 표현되고, 어떤 메소드는 해당 클래스에서 처리되는 반면  
어떤 메소드(abstrace 메소드)는 서브클래스에서 처리되기도 한다.  

> 아.. 그럼 예를 들어 백테스팅 알고리즘 method가 있다면 해당 method는 data load, 매수 알고리즘, 매도 알고리즘  
> 등의 method를 연속으로 호출할텐데, 이때 이 백테스팅 알고리즘을 템플릿 메소드로 만들면,  
> subclass에서는 data load, 매수,매도 알고리즘을 구현해서 여러 백테스팅 알고리즘을 만들수도 있겠다.


## 템플릿 메소드 패턴의 정의

템플릿 메소드 패턴에서는 메소드에서 알고리즘의 골격을 정의합니다.   
알고리즘의 여러 단계 중 일부는 서브클래스에서 구현할 수 있습니다.   
템플릿 메소드를 이용하면 알고리즘의 구조는 그대로 유지하면서 서브클래스에서   
특정 단계를 재정의 할수있습니다. 
  
**즉, 알고리즘의 틀(메소드)를 만들기 위한 패턴 -> 이때 알고리즘 메소드는 일련의 단계(메소드들)로 구성되어 있다.  
이때 여려 단계중 하나 이상의 단계가 추상메소드 이다.** 

p328 : 템플릿 메소드 그림 잘 나와있네 이거 참조 요망

## 템플릿 메소드와 후크

후크 : 기본적으로 아무것도 하지 않는 구상메소드, 서브클래스에서 오버라이드 가능
템플릿 메소드에서 후크를 사용해서, 서브클래스에서 템플릿 메소드의 다양한 위치에서 알고리즘을 끼어들수있다. 

> 그냥 템플릿 메소드에 아무것도 안하는 메소드(후크) 하나 호출하게 넣어둔것. 필요하면 오버라이드 해서 쓴다. 

- [예제](./barista/CaffeineBeverageWithHook.java)

- 언제 템플릿 메소드에서 추상 메소드를 쓰고 후크를 쓰는가?
    - 알고리즘의 중간 단계를 서브클래스에서 교체해야 할때 - 추상메소드
    - 알고리즘의 특정 부분을 선택적으로 적용해야 할때 - 후크
    
-템플릿 메소드에서 추상 메소드가 너무 많아지면 좋지 않다. 서브클래스에서 일일이 다구현해야 해서.
    - 즉 알고리즘의 단계를 적절히 쪼개야 한다. ( 일부는 구상메소드로 제공하고 나머지는 추상메소드로..)

## 객체지향 디자인 원칙 - 헐리우드 원칙

"먼저 연락하지 마세요. 저희가 연락 드리겠습니다."
  
이 원칙을 쓰면 "의존성 부패(dependency rot)"이 방지된다고 한다.   
의존성이 복잡하게 꼬여있는것이 의존성 부패 - p334참조.

- 헐리우드 원칙을 쓰는 패턴
    - 팩토리 메소드, 옵저버.
    
> 할리우드 원칙이 대충 보면 고수준의 구성요소에서 저수준의 구성요소를 호출하고, 저수준에서는 절대 고수준의 구성요소를
> 호출할수 없게 한것..  
> 예를 들면, 템플릿 메소드는 고수준의 구성요소이고, 이 안의 abstract 메소드는 저수준의 메소드..  
> 서브클래스에서 구현한 abstract메소드는 템플릿 메소드(고수준)에서만 호출된다. 

p335 참조 요망.

- 의존성 뒤집기 원칙과 관계? p336
    - 의존성 뒤집기 : 구상클래스 사용을 줄이고 대신 추상화된것을 사용해야 한다는 원칙
        - 팩토리에서 나옴
    - 헐리우드 원칙 : 저수준의 구성요소가 컴퓨테이션에 참여할 수는 있으면서, 저수준의 구성요소와 고수준 계층 사이에 의존성을 만들어내지
      않도록 프레임워크 또는 구성요소를 구축하는 기법
    - 여튼 의존석 뒤집기 원칙이 훨씬 일반적이고 강력하다고 함
    
> (중요) 어.. 형태가 팩토리메소드랑 템플릿 메소드랑 비슷한데? 해당 메소드에서 abstract 메소드를 쓰고 있고.
> 해당 abstract메소드는 subclass에서 제공한다는 점이 비슷

## 정리

여튼 템플릿 메소드 패턴은 매우 많이 쓰이는 패턴이라고한다. 근데 실전에서는 교재 내용과 꽤 다르게 구현한 템플릿 메소드들도 많이 있어서  
자세히 보지 않으면 템플릿 메소드 패턴이 적용된 것을 모른다고함.  
  
프레임워크를 만드는데 많이 쓰이는 패턴이라고함. -p337

## 야생의 샘플 (실전 샘플)

### sort

java Array의 sort함수에서 사용하는 mergSort가 템플릿 메소드임 ( 주석상 legacy다)  
근데 기존 배운 템플릿 메소드랑 다른점은 "서브 클래스"를 이용하지 않는다는 점 

```java
Array.sort(); // 이렇게 sort는 static method다. 따라서 쓸때 subclass를 만들지 않는다. 
```
따라서  sort에서는 받는 배열객체의 객체가 compareable interface를 implement해야한다.  - Duck예제 참조

- 이거 템플릿 메소드 패턴 정의랑 다른데? 상속을 이용하지 않고 있잖아? - p343 
    - 원래 실전은 그런거다
- 이거 스트래티지 패턴 아닌가? - p343
    - 비슷하다고 할순 있는데.. 구성을 이용하니까 (duck객체를 넘겨서 duck의 compareTo가 호출됨)
    - 하지만 스트래티지 패턴은 구성객체가 알고리즘을 온전히 제공한다면
    - 템플릿에서는 알고리즘의 일부를 구성객체가 제공
    
### 나머지

frame, applet은 그냥 책참조. p344

## 템플릿 vs 스트래티지 - p347

템플릿 : 알고리즘이 약간 변하는 부분이 있을때 이득
스트래티지 : 알고리즘 전체가 변할떄 이득
  
스트래티지: 구성을 이용하니까, 유연성에서 이득 ( 클라이언트에서 객체만 바꿔끼면 된다.)
템플릿 : 코드 재사용할수 있게 하니까(이게 장점), 프레임워크 만드는데 완벽함. 
         => 스트래티지는 interface를 구현한 구성객체를 쓰니까, 코드 재사용은.. 당연 아니겟지. 사실.. 그럴 필요도 없어서 그런거 같긴하고
템플릿 : 의존성 큼 ( 왜냐면 알고리즘의 일부를 수퍼클래스에서 구현한 메소드에 의존해야함. 스트래티지는 아님.)

- p349  
    - 팩토리 메소드 패턴은 특화된 템플릿 메소드 패턴이다.
    - 스트래티지 패턴은 구성을 , 템플릿 메소드 패턴은 상속으로 알고리즘을 캡슐화