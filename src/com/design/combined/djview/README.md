# 컴파운드 패턴 (MVC)

- 진정한 컴파운드 패턴.  
- MVC를 이해하는 데는 패턴을 아는게 중요
- MVC
    - view : mp3의 디스플레이
    - Controller : 사용자가 버튼/인터페이스를 누르면, 컨트롤러가 그 메시지를 model에 전달
    - model : 로직 처리 + view에게 상태 변화 통지
    
## MVC 간단 설명

- 뷰에서는 일반적으로 화면에 표시할 상태 데이터는 모델에서 직접 가져옴.
- 모델은 인터페이스를 뷰와 컨트롤러에 전달
    - 상태 변경시 옵저버들에게 상태를 전달해 주기도 함.
- 사용자는 뷰하고만 접촉가능
    - 뷰에서 사용자의 행위를 컨트롤러에 전달
- 컨트롤러는 사용자의 행위에 따라 모델을 어떤 식으로 조작해야 하는지 결정
- 컨트롤러에서 뷰를 변경해 달라고 요청할수 있다.
    - 뷰에서 어떤 행동을 받앗을때, 그 행동의 결과로 뷰를 바꿔달라고 할수 잇음
    - 예를 들어, 컨트롤러에서 인터페이스에 있는 어떤 버튼이나 메뉴를 활성화 / 비활성화 시킬수 있음
- 상태가 변경되면 모델에서 뷰한테 그 사실을 알립니다. 
- 뷰에서 모델한테 상태를 요청합니다.
    - 예를 들어, 
        - 모델에서 뷰에게 새로운 곡이 재생되기 시작했다고 알려주면, 뷰에서 모델한테 곡 제목을 요청하고, 받아서 화면에 표시
        - 컨트롤러에서 뷰를 바꾸라는 요청을 했을때도, 뷰에서 모델한테 상태를 알려달라고 요청
    
## Q&A - p569
- 컨트롤러가 모델의 옵저버가 되는경우도 있다. 
- 그냥 뷰랑 모델만 있으면 되지 않나? 즉, 그냥 뷰에 모델 코드를 추가 (컨트롤러 빼고..) 
    - 컨트롤러는 단순히 모델한테 메시지를 전달하는 역할을 하는게 아니다. 사용자 메시지 해석 및 모델을 조작하는 역할을 한다.
    - 뷰에 모델을 통합하는 경우.. 단점
        - 뷰 코드가 복잡해짐. 
            - 사용자 인터페이스 관리도 해야 하고..
            - 모델을 제어하는 로직도 처리해야 한다. 
        - 뷰를 모델에 너무 밀접하게 연관시켜야 한다.
            - 즉, 이경우 뷰를 다른 모델과 연결해서 재사용하기 매우 힘들어진다.
    - 즉, 컨트롤러는 뷰와 모델의 결합을 끈어주는 역할. ( 즉 느슨한 결합을 유도)
    
## MVC 설명 두번째.

- MVC에는 스트래티지 패턴, 옵저버 패턴, 컴포지트 패턴이 쓰임
    - 뷰 : 컴포지트 패턴으로 윈도우,버튼 등 관리
    - 뷰 : 스트래티지 패턴으로 컨트롤러(전략/알고리즘)을 관리
    - 모델 : 옵저버 패턴으로 상태 변화를 뷰나 연관된 객체에 알림.
    
## djview (MVC 패턴 예제)

- 모델 (BeatModel)
    - 컨트롤러, 뷰를 위한 인터페이스 제공 필요
    - 데이터, 상태, 로직 관리
    - 옵저버 등록 가능
- 뷰
    - 모델용 뷰
        - 모델의 data를 보여주는 뷰.
        - update method만 구현
        - 모델 상태 변화시 noti를 알려주면 update가 호출됨.
    - 사용자 인터페이스 뷰 
        - 컨트롤러 호출
        - 버튼 리스너 동작에 컨트롤러 호출
    - 예제에서는 위 두 뷰는 하나의 class로 구현됨
- 컨트롤러   
    - 뷰의 전략(알고리즘)
    - 이게 MAIN (본 예제만 그런지는 모르겠음.)
        - 예제에서는 컨트롤러 내에서 뷰를 만드는데.. 
        - 모델 초기화 및 뷰 띄우기 위한 전처리를 모두 여기서 함. 
            - 아마 이부분을 따로 빼면 코드가 애매해지니까, 원래 컨트롤러에서 담당하는거 같기도 함.
    
모델은 뷰와 컨트롤러를 모른다. 다만 뷰와 컨트롤러를 위한 인터페이스는 제공해야 한다.   
(예제에서 뷰는 모델을 이용하긴 하는데, 모델의 뷰를 위한 기능만 사용.)  
컨트롤러는 둘다 ref함.  
컨트롤러와 뷰는 서로 ref하네. ( 컨트롤로가 뷰를 일부 제어. 버튼, en/disable.) 
  
뷰는 모델에 옵저버 등록을 하였기때문에, 모델의 상태 변화시 UI변경 로직은 뷰에서 진행하고 있다... ( 컨트롤러를 통하지 않음.) 
> 원래 컨트롤러의 역할이 모델에게 사용자 메시지를 전달하는거라, 거기에 관련된 interface빼곤 없어서 그런거 같기도..
> 이과정에 뷰의 제어가 필요한 경우만 제어하고..  

### 예제 2 (HeartModel)

위 예제는 beatModel에 대한 내용. 이제 뷰는 그대로 두고 모델을 변경해본다. ( 즉 GUI를 그대로 이용할때.. )
- 일단 바뀐 모델에 대한 컨트롤러 필요
- beatModel과, heartModle은 일부 interface가 다름. 뷰에서는 beatModel interface를 쓰므로.. 맞춰 줘야함 (어댑터)

> 그나마 컨트롤러 interface에는 어댑터 만들지 않아도 되네.. 원래 MVC가 이런형태인가?  
> 즉, 모델은 어댑터를 쓰고, 컨트롤러는 쓰지 않아도 되게? 아닐꺼 같긴함..
  
p384 : 원래 MVC패턴을 쓰다보면 어댑터 패턴을 적지않게 쓴다. 어떤 모델을 기존의 뷰 또는 컨트롤러와 같이 쓰기 위함  

- 뷰 
  - 변경사항 없음
- 컨트롤러 
  - 새로 하나 만듬. ( 바뀐 모델에 맞게 작업함 )
  - 사실 컨트롤러도 기존 BeatController에 HeartModel을 어댑터로 싸서 넣고 사용할수도 있겠지만  
    기본적으로 컨트롤러에서 view도 다루기 때문에, 새로 만들어 주는게 맞는듯.. view 제어가 맘에 들지 않을수 있어서..
  - 보면 뷰에 대한 초기세팅도 달리함.  
- 모델
  - 새로 만듬.
  - view에서 사용하는 beatinterface에 맞춰주기 위한 어댑터도 필요
    
## p590

MVC의 정리.

## p597

- 컨트롤러에서 애플리케이션 로직을 구현하는 경우는 없나? ( 즉 모델 처럼)
    - 없다. 
    - 컨트롤러는 뷰를 위한 행동을 구현한다. ( 즉, 사용자의 요청을  모델에 대한 요청으로 변경 )
    - 물론, 컨트롤러에서 모델의 어떤 메소드를 부를지 결정하긴 하는데, 이게 애플리케이션 로직은 아니다.
        - 애플리케이션 로직이란 : 데이터를 관리하고 조작하기 위한 코드
- 컨트롤러가 Mediator 패턴인가?
    - 약간은 맞는데, 진정한 Meditator는 아님.
    - 뷰에서 모델에 대한 ref가 있긴 하니까..
        - 진정한 Meditator였다면 뷰에는 모델의 ref가 없어야함.
        - 즉 모델 상태읽는것도 컨트롤러가 해야 진정한 Meditator
- 모델에서 push방식을 이용해도 되지 않나?
    - 즉 notiy를 알릴때 상태값도 전달
    - 이거 단점 있다함. 옵저버 패턴의 push 확인 (p100)
        - 단점은 원하지 않는 data도 받게될수 있다는것, 즉 필요한 data만 가져가는게 좋다( 뭐 항상 push가 안좋다는것은 아님)
- 뷰에서 모델을 직접 수정하는 api를 호출가능하긴 하던데?
    - ㅇㅇ 예제는 그러함. 
    - api 제한이 필요한경우는 프록시 쓰면 되는듯
    
## 아주 간단 MVC 정리

- M : data, 비지니스 로직 있음
- V : UI관련 요소. 버튼 클릭시 호출하는 이벤트는 C를 호출 
- C : V에서 사용자가 버튼 클릭시 트리거링 되는 class. View 와 Model을 제어한다. 
        - 비지니스 로직은 M에 있기때문에, M이 export하는 api를 적적히 사용하는 형태.