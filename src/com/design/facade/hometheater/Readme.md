# 퍼사드

어댑터 패턴에서 확장된것.  
하나 이상의 클래스의 복잡한 인터페이스를 깔끔하면서 말쑥한 퍼사드(겉모양, 외관)으로 덮어주는것

| 패턴       | 용도                                       |
| :--------- | :----------------------------------------- |
| 테코레이터 | 인터페이스는 바꾸지 않고 책임(기능)만 추가 |
| 어댑터     | 한 인터페이스를 다른 인터페이스로 변환     |
| 퍼사드     | 인터페이스를 간단하게 바꿈                 |

> 보니까 그냥 class만들어서 여러 class(서브시스템) 를 이용한것 뿐.. 
> HomeTheaterFacade 코드 보면 앎.

## hometheater예제

p294 - 홈씨어터에는 여러가지 class가 있고 연결되어 있는데, 영화를 보는 기능을 만드려면, 6개 class의 
기능을 순차적으로 이용해야 한다. => 매우 번거롭고 불편.

## 퍼사드 어댑터 차이 - p298

어댑터는 인터페이스 변환을 위함. 이때 여러 class를 이용할수도 있다고함  
퍼사드도 여러 class를 감싸는거 대신 복잡한 한개의 class를 감쌀수도 있음  
  
핵심은 용도의 차이
- 퍼사드는 어떤 서브시스템(class)에 대한 간단한 인터페이스 제공목적

> 근데 퍼사드는 어댑터랑 형태가 달르긴함.. 
> 어댑터는 어댑티를 구성으로 가지고 타겟interfcae를 상속하는데, 
> 퍼사드는 서브클래스들을 구성으로 가지지만, 타켓 interface를 상속하는 것은 없음.. 그냥 지가 
> 서브 클래스들을 조합해서 사용하는 단순한 method(interface)를 만드는것뿐..

## 퍼사드 패턴 정의

어떤 서브시스테므이 일련의 인터페이스에 대한 통합된 인터페이스를 제공. 퍼사드에서 고수준 인터페이스를   
정의하기 때문에 서브시스템을 더 쉽게 사용할 수 있다. 

> 퍼사드가 굉장이 단순한 패턴이긴함( 복잡한 추상화 필요없음)  
> 퍼사드 이용시 클라이언트와 서브시스템간의 연결이 약해지고, 아래 나올 새로운 객체지행 원칙 준수에도 도움됨

## 객체 지향 원칙 - 최소 지식 원칙 = 데메터르의 법칙

**정말 친한 친구하고만 상호작용해라!**

> 즉 최소 지식은, 상호작용하는 객체를 줄여야한다는 의미 같다. 

객체는 그 객체와 상호작용하는 클래스 갯수에 주의해야 하고, 그 객체들이 어떤 식으로 상호작용하는지도  
주의를 기울여야 한다.
( 즉, 여러 클래스들이 복잡하게 의존하면, 한 부분을 변경하였을때 다른 부분까지 줄줄이 수정해야한다. 
그리고 관리도 힘듬.)

> p305 : 위 원칙의 단점으로는 "래퍼" 클래스를 더 만들어야 할수도 있다. 
> 그러면 시스템이 복잡해지고, 개발 시간도 늘어나며, 성능도 떨어질수 있음.

- 모든 원칙은 상황에 따라 적재 적소에 사용해야 한다.   

## 어떻게 하면 여러 객체하고 의존하는것을 피할수 있을까? (중요)

어떤 메소드에서든지 다음 네 종류의 객체의 메소드만을 호출하면 된다. 
- 객체 자체 (this)
- 메소드에 매개변수로 전달된 객체 (method param)
- 그 메소드에서 생성하거나 인스턴스를 만든 객체 
- 그 객체에 속하는 구성요소 (다른 객체를 참조하는 변수를 말함)

위 가이드라인에 따르면, 다른메소드를 호출해서 리턴받은 객체의 메소드를 호출하는 것은 바람직하지 않다.

> 위 내용은 p304를 직접 보는게 좋다.
> 근데 보니까 "다른메소드 호출로 리턴받은 객체 사용" 빼고는 모든 상황의 객체 상호작용이 가능한 가이드 같은데??


## 최소 지식 원칙과 퍼사드

p306은 애매함..
p307 - 퍼사드를 쓰면 client는 퍼사드에만 상호작용 하게됨. 즉 상호작용하는 객체가 적다.
-> 물론 client(main) 에서 서브시스템 객체를 생성하긴 하는데, 따로 상호작용하진 않음.
