데코레이터 패턴

예시는 스타벅스 문제인데, Beverage 추상클래스를 상속한 subclass들이 각각의 음료가 된다.
이때 음료에 토핑이 추가되거나, 토핑 가격이 변경되거나.. 등등의 변화가 있을수 있다.

예시에서는 처음엔 모든 토핑 상황에 따른 class를 전부 구현하였다가( class가 어마어마하게 많아짐 ),
그다음엔 토핑 변수를 Beverage에 추가하는 형태로 구현..

위 두가지는 매우 좋지 않은 설계 이다.

디자인 원칙)
  구성과 위임 : 앞서 옵저버에서 계속 나오던 내용

다자인 원칙)
  OCP(open-closed principle) : 클래스는 확장에 대해서는 열려 있어야 하지만 코드 변경에 대해서는
  닫혀 있어야 한다.
  > 옵저버도 한가지 예이다. *subject에 옵저버를 추가함으로써 Subject변경없이 기능이 추가되긴 함.
  > 데코레이터 패턴도 한가지 예

중요 포인트!)
  디자인 할때 모든 부분에서 OCP를 준수하는 것은 불가, 이걸 지키려다 보면 새로운 단계의
  추상화가 필요하기도 하고, 그러다보면 코드가 복잡해짐.
  따라서 디자인한 것중 "가장 바뀔 확률이 높은 부분"을 중점적으로 보고 원칙을 적용하는 것이 좋다.

데코레이터 패턴 키포인트!)
  장식할 class의 superclass와 같은 class를 데코레이터도 상속한다.
  이렇게 하면 장식할 class가 있던 위치에 데코레이팅한 객체를 넣을수 있다. 

의문)
  근데 만약 데코레이팅 하기전 target객체가 자신만의 특별한 method를 만들었다면?
  데코레이팅 한 객체로는 해당 함수를 호출할 수는 없을듯.. (구성이라서.. )
  이경우 데코레이터 class도 해당 target에 맞춰서 따로 하나 만들어야 하나?

특별한 것)
  super class의 일반 method를 상속할때 abstract로 변환해도 되나봄. -> CondimentDecorator참조

이슈들이 있다. p137)
1. 만약 구상구성요소(즉, 명확한 객체)의 type을 확인해서 작업하는 부분에는 데코레이터를 쓸수는 없다.
   왜냐면, 데코레이터를 쓰면 객체의 type이 달라지는 거니까.
   따라서 추상 구성요소 형식으로 돌아가는 데에만 데코레이터를 쓸수 있따.
   즉, 특정 형식에 의존하는 곳에서는 쓰기 어려움
2. 데코레이터 class가 많아질수 있다. (ex:inputstream)
3. 구성요소를 초기화하는 데 필요한 코드가 복잡해지고, 많은 데코레이터로 감싸야하는 경우가 있다.
   따라서.데코레이터는, 팩토리나 빌더와 같이 쓴다. (실수를 줄이기 위해 )

정리)
 - 상속은 디자인의 유연성 면에서 별로 좋지 않다. ( 서브클래싱 개념으로 코드의 중복이나 재사용 측면에선 유리하겠지만.. )
 - 상속 대신 데코레이터 패턴으로 행동을 확장할수 잇따. ( 행동 개념은 여기서도 나오네..행동=메시지? )
 - 데코레이터 패턴에서는 구상 구성요소를 감싸주는 데코레이터들을 사용한다.
 - 데코레이터 패턴을 사용하면 자잘한 객체들이 매우 많이 추가될 수 있고, 데코레이터를 너무 많이 사용하면
   코드가 필요 이상으로 복잡해 질 수도 있다.

 * 구상 구성요소 : class의 객체 변수