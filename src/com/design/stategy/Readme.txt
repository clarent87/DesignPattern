1. 패턴 소개
본 챕터에서는 strategy(전략) 패턴을 소개하고 있음.

문제상황)
Duck super class가 있고, 이걸 상속해서 다양한 파생 클래스를 많듬
근데 Duck에서 제공하는 함수중 일부는 파생 클래스에서 호출되면 안되고 (ex: fly()함수 ), 동작도 달라야한다.
- 즉 subclass마다 method의 행동이 달라질수 있고, subclass는 무수히 많아 질수 있는 상황

잘못된 해결책 : interface로 문제가 되는 method를 뽑는다.
- 이 경우 subclass중 문제가 되는 method 호출이 없는 경우는 풀리긴 하지만..
- 이 경우 모든 subclass에 interface를 상속해서 method를 정의해야 한다.
  ( 전혀 코드의 재활용이 되고 있지 않음, 왜냐면 같은 동작의 method라도 subclass마다 전부 작성해 줘야함.. interface implement.. )

중요 개념!
디자인 원칙 첫번째)
    애플리케이션에서 바뀌는 부분은 분리해서 캡슐화 한다. p.47 ( 따로 class로 빼라는거 같음 )
디자인 원칙 두번째)
    구현이 아닌 인터페이스에 맞춰서 프로그래밍 한다. ( 즉, interface기반 method call )
    - 이는 java 인터페이스에 맞추라는 것보다는 상위 형식(interface, abstract)을 이용하라는 말
    - 실제 객체 생성은 new Dog() 처럼 실제 객체를 만들기 보다는 getAnimal()같은걸 이용해서 객체를 받는게 좋다고 함

캡슐화 되었다는것은
- 인터페이스 및 구현 개념을 사용했다는것 ( 예제의 fly, quack 같은 경우를 말함 )

구성이란?)
이런식으로 Duck의 행동을 위임해서 class를 만들고 합치는 형태를 구성(composition)을 이용했다고 말함.
예제에서는 행동을 상속 받는 대신, "행동 객체"를 구성하였다.

디자인 원칙 세번째)
    상속보다는 구성을 이용한다.


Strategy Pattern)
    스트래티지 패턴에서는 알고리즘군(ex: fly, quack)을 정의하고 각각을 캡슐화하여 교환해서 사용할 수 있도록 만든다.
    스트래티지를 활용하면 알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다.
    > 즉 구성(composition)을 이용하는 것 ( 알고리즘 객체를 가지고 있고, 알고리즘 수행시 객체의 알고리즘 method를 호출하게 하는것 )
    > 이때 객체를 변경하기만 하면 다양한 알고리즘으로 교체 할수 있음