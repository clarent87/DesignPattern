# 어댑터 패턴

어댑터 패턴은 인터페이스 변환을 위해 사용  
> 즉 기본적으로 java 인터페이스 사용환경에서 쓰는듯. 

> 구현은 데코레이터랑 동일함. 
> 그리고 객체지향 원칙 중 "구성" 이이용됨 ( 어댑터의 어댑티.)
>

용어

- 어댑터 : 타겟 인터페이스를 구현하고 어댑티를 타겟 인터페이스에 맞추는 역할.
- 어댑티 : 어댑티는 어댑터를 이용해서 감싸는 객체

## duck 예제

여기서는 Duck, Turkey 인터페이스가 있는데, Duck위치에 Turkey를 사용하기 위해 어댑터를 만듬 또는 Turkey위치에 duck을 사용하기 위한 어댑터를 만듬

- Duck 위치에 Turkey를 사용하려고 할때.
    - 어댑티 : turkey
    - 어댑터 : 타겟 인터페이스(Duck)을 구현하고 Turkey객체는 구성으로 가지고 있는다. 그리고 인터페이스 메소드 구현에 Turkey의 method를 이용

### info - p280

- 타겟 인터페이스가 큰경우 어댑터 만드는거 어렵지 않나? ( 즉 어댑터에서 implement한 interface, abstract class가 방대한경우.)
  - 어댑터 말고는 마땅한 대안이 없다. ( 모든 변경사항을 캡슐화한 클래스 한개 제공하는 형태인 어댑터가 나음)
- 한 어댑터에서 한 클래스만 감싸야 하나. (즉, 어댑티를 하나만 이용해야 하는지..)
  - 타겟 인터페이스를 구현하려고 할때, 어댑티가 여러개 필요할 수도 있다. => 퍼사드와 연관됨
- 다중 어댑터
  - 두가지 타겟 인터페이스를 지원하는 어댑터. (이부분은 설명을 정확히 이해한건지 모르겠다. )
  
## 어댑터 패턴 정의 

한 클래스의 인터페이스를, 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환합니다.  
어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.
  
이 패턴을 사용하기 위해서는 client가 구현이 아닌 인터페이스에 연결되어 있어야한다. (p281)  
  
위 내용은 예를들어 DuckTestDrive의 testDuck method가 client이고 해당 메소드는 Duck인터페이스에 연결되어 있어서  
어댑터가 사용가능했다. 
- 근데 사실 특정 구현 MallardDuck이었어도, 이걸 상속하는 어댑터를 만들면 되지 않나?
- 음.. 아마 **인터페이스 연결** 이라는 것은 원래 그냥 구상class의 객체를 직접생성해서 구현할수도 있는데
  이부분을 구상 class대신 인터페이스 변수로 일단 구현하고, 나중에 객체를 연결해서 쓰는것을 인터페이스 연결이라고 표현한듯..
  
> 객체지향 원칙중, client를 특정 구현이 아닌 인터페이스에 연결 시키라는 것은  
> 코드를 짤때 구상class의 객체를 직접생성해서 작성하는 것이 아닌, interface 변수를 두고 일단 작성후
> 나중에 객체를 받아서 interface에 연결하라는 의미 같음.

## 어댑터 종류

어댑터는 아래 두가지 종류가 있다. 

- 객체 어댑터 
  - 앞 ducks 예제가 객체 어댑터
  - 구성을 이용해서 어댑티를 사용함 
- 클래스 어댑터
  - 다중 상속이 가능해야 하는데, 일단 java는 다중상속이 불가 -p282
  - 다중상속이 가능한 언어에서는, 어댑터 class를 타겟과  어댑티의 다중상속을 통해 만들어서 사용하면 된다.   
    즉, 이경우 어댑터에 타켓의 method를 override하는데, 상속한 어댑티의 method를 이용해서 만들면될듯
  - 즉, 구상대신 상속으로 어댑티를 다룸
    
> "클래스 어댑터"의 경우 client가 인터페이스에 의존이 아닌, 타켓 구상class에 의존해도 상관없을듯.. 
> 근데.. 사실 객체 어댑터도.. client가 구상class에 의존하고 있어도 상관없을거 같긴한데..
> 이경우 구상class의 method를 override하기 부담스러워서 그러나.. ( 왜냐면 구상 method는 완성된 method인데,, override하는게.. 쫌 그럼?)

p285 - 객체 어댑터 vs 클래스 어댑터 : 쫌 이해하기 애매한 부분들이 있네.
  - 클래스 어댑터를 만들면, 어댑티는 없어도 된다 ( 그냥 클래스 어댑터 객체 만들어서 쓰면됨)

## 실전 예제 (iternum 예제)

옛날 자바에서는 초기 컬렉션(Vector, Stack.. 등등)형식 에서는 Enumeration 인터페이스를 구현했었다.
썬에서 만든 새로운 컬렉션 class들은 Enumeration대신 Iterator라는 interface를 쓰고 있다.  
따라서 어댑터를 이용해서 구형 컬렉션들을 신형 코드(Iterator interface이용)에 쓰게 할수 있다. 
  
이때 Iterator에 있는 method(remove)가 Enumeration에 없는경우 처리는? 기본적으로 완벽하게 만들수는 없다. 가장 좋은방법은  
없는 method에 대해서는 어댑티에서 제공할수 없으므로, runtime error를 던지는 방법이 있다.  
Iterator 인터페이스 같은경우, remove메소드를 구현할떄 UnsupportedOperationException을 지원하도록 만들어짐. 


## 데코레이터와 어댑터 비교

데코레이터는 "책임(행동)" 이 추가/확장되는거고, 어댑터는 그냥 인터페이스 변환
