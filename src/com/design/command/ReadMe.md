# 커맨드 패턴

한차원 높은 단계의 캡슐화. => 메소드 호출을 캡슐화

커맨드 패턴을 이용하면, 작업을 요청한 쪽하고, 그 작업을 처리한 쪽을 분리 시킬수 있다. 

> 음.. 어댑터 패턴과 유사 한가? 

## 구성요소

- 커맨드객체 : 리시버 객체를 구성으로 사용하고, execute에서 리시버 객체의 행동을 진행함. ( execute가 일반적으로 커맨드 객체에서 제공하는 메소드 )
- 리시버 객체 : 활용해야 할, 주어진 class -> 커맨드 패턴은 여러 리시버 객체의 **일련의 작업**을 정형화된 인터페이스(execute)를 이용해서 사용하기 위함인듯 
- 인보커객체 : 커맨드 객체를 세팅(저장) 하고, execute함수를 호출하는 녀석
- 클라이언트 객체 : 프로그램 시작.

구성요소에서 커맨드 객체는 리시버 객체에 의존하는것으로 보임  
인보커 객체는 커맨드 객체를 전달받아서 "필요한 작업 요청"에 대응함 

> 커맨드 객체는 리시버 한개당 하나가 아닌라, 리시버의 여러 기능을 이용해서 여러개 만들수 있음 (ex: on,off 커맨드 예시 처럼)
> 인보커 객체는 여러개 커맨드를 저장하고 있을수도 있음 ( 만들기 나름. )
> 커맨스 객체에 전달하는 리시버는 여러커맨드에 같이 쓸수 있음


## simpleremote

기본 예제 설명임 

## 커맨드 패턴 정의

커맨드 패턴을 이용하면 "요구 사항을 객체로 캡슐화" 할 수 있으며, "매개변수"를 써서 여러 가지 다른 요구 사항을 집어넣을수도 있다. 
또한 요청 내역을 큐에 저장하거나 로그로 기록할 수 도 있다. 작업 취소 기능도 가능

- 요구사항 캡슐화
    - 리시버가 커맨드 객체에 연결된 부분 (리시버의 일련의 작업을 객체에 넣음.ex: execute 메소드에 의해 요구사항이 처리됨)
- 매개변수화
    - 커맨드 객체를 인보커의 매개변수로 전달 하는 부분

> 메타 커맨드 패턴. 나중에 나오나봄, 이걸 이용하면 명령들로 이루어진 매크로를 만들어서 여러개의 명령을 한번에 처리 가능

커맨트 패턴을 이용하면, 인보커 코드는 거의 변경될 일이 없다. 

## remote 

책 예제 리모컨 만드는 예제, simple이랑 차이는 없다. 
stereoOn커맨드는 한번 볼만하다 .( 스테레오 객체의 여러 행동을 execute 메소드에 추가함)

> p249에 결합이라는 용어가 쓰이는데, 결합은 그냥 "사용" 이란 의미로 받아들이면 될거 같다.

**NoCommand**는 일종의 null 객체인데, 널 객체도 일종의 디자인 패턴으로 분류하기도 한다.
상당히 괜찮다. 예제에서는 빈 slot인지 확인을 `!=null`로하는것보다 그냥 null 객체의 execute함수를 호출하게 하였다.

## Undo 

remote에서 undo가 추가된 예제. command interface에 undo 메소드가 추가됨.  
그리고 간단한 상태를 다루는 부분도 있음   
예를 들어 선풍기의 fan속도 가 high였을때 medium으로 바꾸고 undo를 하면 high가 되어 야함.  
즉 이때 선풍기는 fan속도의 변경전 속도를 가지고 있음

즉 리시버에 상태가 있고, 각각의 커맨드에서 상태를 업데이트, 그리고 각각의 커맨드에서 undo를 구현할때  
리시버의 상태값(pre)을 보고 원하는 행동을 구현.

> 커맨드 패턴의 핵심은, 인보커는 리시버가 아무리 추가되도 변할일이 없다는것.

## macro command (party예제)

별거 없다. 그냥 여러 리시버의 기능을 한번에 동작시키는 커맨드를 추가한것. 
이때 매크로 커맨드에는 리시버들을 받는게 아니라, 커맨드들을 받아서 사용한다.   


## 커맨드 패턴 활용 -p266

- 작업큐에 사용가능. 즉 커맨드들을 만을더서 큐에 저장해두고, thread가 빌때마다 해당 thread는 큐에서  
  커맨드 객체를 빼와서 execute를 호출.

- 작업 히스토리를 남길때 사용. 이부분은 그냥 이쪽 page를 읽는게 좋을거 같다..  
  대충 설명하면, 방대한 data를 연산해서 저장해야 하는 커맨드가 있다고 하면, 매번 연산후 해당 data를 저장하는것은  
  오버헤드가 크다..
  이럴때 command에 store/load method를 준비해 두고 구현해서 execute 때마다, store를 호출해서, 실행된 command를  
  로그에 기록한다
  이후 프로그램에 갑자기 죽었다면, 로그에 기록된 작업을 load해서 실행... 뭐 이런 식인거 같다.
  사실 이해가 애매하게만 된다.

## 기타. 

커맨드 만들때 execute에서 리시버의 행동을 이용하는데, 이렇게 안하고 그냥 커맨드의 execute에서 알아서  
처리하는 smart커맨드를 만들기도 한다함 ( 이경우는 리시버는 필요없나봄. ) - p268,265