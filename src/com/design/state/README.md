# 스테이트 패턴 (객체의 상태)

스트래티지랑 원래 쌍둥이라고 함.

## gumball

단순 상태 머신 구현, 상태는 class의 "final static" 변수로 둠.   
상태가 추가되면 모든 부분의 if문이 추가되야 하는 단점이 있음.

## gumballstate

각각의 상태 객체를 생성 (기존 method들을 상태 객체에서 작업).  
상태는 GumballMachine에서 관리.   
기존 method들을 각각의 객체에서 처리함.  
즉 GumballMachine은 상태만 추가하면됨..
  
알맹이 count관련된 내용은 GumballMachine에서 관리  

> 그냥 예제를 보면 쉽게 알수 있음.  
> 중요한것은 State interface를 잘 뽑아야 할듯.. 즉 상태와 상태변화를 유발하는 행동(method)만 추가해야 하는거 같음.
  
p455 : OCP 만족 ( 각 상태를 변경에 대해서는 닫혀 있다, GumballMachine 은 새로운 상태를 추가하는 확장에 대해 열려 있다.)

## 스테이트 패턴 정의

스테이트 패턴을 이용하면 객체의 내부 상태가 바뀜에 따라서 객체의 행동을 바꿀 수 있습니다. 마치 객체의 클래스가   
바뀌는 것과 같은 결과를 얻을 수 있습니다.
  
즉 상태를 캡슐화함.  
p448 : class 다이어 그램  

## 스테이트 패턴 VS 스트래티지 패턴 p449

둘다 다이어그램은 같음  
-  스테이트 패턴
    - 객체 상태의 일련의 행동이 캡슐화 됨
    - context 객체는 상태에 따라 행동이 바뀜
    - 클라이언트는 상태 객체에 대해서는 몰라도 됨
      ex: 클라이언트(main) 에서 context객체(GumballMachine)에게 상태객체에 대해 물어볼수도 없고 세팅할 수도 없음. 
    - context객체에 수많은 조건문 대신 집어넣을 수 있는 패턴 -> 오오....  

- 스트래티지 패턴
    - 클라이언트에서 context객체에게 어떤 전략 객체를 쓸지 지정해줌 
      ex: 1장을보면 클라이언트(main)에서 context객체(ModelDuck)에게 전략을 setFlyBehavior method로 변경해줌
    - 즉, 실행시 전략 객체를 변경할 수있는 유연성 제공을 위함 ( 보통 가장 적합한 전략 객체를 선택해서 사용 - ModelDuck 초기 세팅 처럼)  
    
## p450 Q&A

- 상태 전환 흐름은, 예제처럼 concrete 상태 class대신 context에서 해도 되긴한다. 
    - 근데 예제처럼 상태 전환이 동적으로 결정되는 경우(ex: 알맹이 갯수에 따라 soldout이 되기도 함)  
      상태 클래스 내에서 처리하는 것이 좋음.
- 상태 전환 코드가 상태 클래스에 있으면, 상태 클래스들 사이에 의존성이 생김 
    - 예제는 그래도 context의 getter를 이용해서 의존성을 줄이는 노력을 함
- 상태 전환 흐름 코드를 어디에 넣냐에 따라 어떤 클래스(context or state)가 변경에 대해 닫혀 있는지 결정됨
    - 예제는 state class에 상태 전환이 있어서, 변경에 대해 닫혀있고, context는 확장에 대해 열려있음.
- clinet는 state 객체에 대해 알지 못해야 한다. 
- context가 많은 경우 여러 context에서 상태 객체를 공유해도 된다. - 이부분은 p450 참조
    - 이때는 객체를 static 변수로 둔다는것. 그러면 context에서 객체 공유가 되니까..
    - 이때는 당연히 state 객체가 자신의 상태를 관리하는 기능이 있으면 안된다. ( context들이 공유해서 쓸꺼니까..)

## gumballstatewinner

당첨 기능 추가. context에 추가는 쉽고, HasQuarterState에 당첨로직을 추가하긴 해야 함  
( OCP..가 완벽히 들어 맞진 않은거 같네..상태가 변경에 대해 닫혀있지 못하니까..)